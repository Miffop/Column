Variables:
#<variableName>::<valueOrExpression>;
#<varName>|<subVarName>::<valueOrExpresion>;
#<varName>|(<ExpresionReturningSubVarName>)::<valueOrExprsion>;
#<varName>|<subVarName1>|<subVarName2>::<valueOrExpresion>;{every variable or subvariable may have subvariables}

Literals:
"someString"-string
'c'-charecter{its code stored as an integer}
383 - integer
3.14 - real

Operations:
  + add {if you add string and int, int will be tread as char}
  - subract
  * multiply
  / divide
  % module
  _ negate {you CAN do like this: #a::-1}{but better use this #a::_1}
  ** power
  == equal
  != not equal
  > greater
  < less
  >= greater or equal
  <= less or equal
  << shl
  >> shr
  & bitwise and
  . bitwise or
  ^ bitwise xor
  ~ bitwise not
  && logic and
  .. logic or
  ^^ logic xor
  ~~ logic not
  = get value
  <pointer> has <subVariableName> if pointer contains this subvariable returns 1 else 0
  <pointer> sub <subVariableName> returns subvariable of the pointer(if subvariable doesn't exists it creates one)

Operations order:
  1)()
  2)~,~~,_,=
  3)**
  4)*,/,%
  5)+,-
  6)<<,>>
  7)<,<=,>,>=
  8)==,!=
  9)&
  10)^
  11).
  12)&&
  13)^^
  14)..
  15)has,sub

Operators:
  !if(<condition1>){0-false, noneZeroValue-true}
  //
    <...>
  \\
  !else !if(<condition2>)
  //
    <...>
  \\
  !else
  //
    <...>
  \\
  
  !while(<condition>)
  //
    <...>
  \\
  
  !for(<counterInit>;<condition>;<counterIncrement>;)
  //
    <...>
  \\
  
  !repeat
  //
    <...>
  \\
  !while(<condition>)
  
  !try
  //
    <...>
  \\
  !catch
  //
    <...>
  \\
  
  !break - break out of the cycle
  !continue -move to the next iteration of the cycle
  !nop - do nothing
  !ret - exit the method

Methods:
  !meth $<methodName1>(#<argument1>,#<argument2>,...){Creating method}
  //
     <...>
     !meth <methodName2>(){Createing a method inside the method}
     //
        {When Creating the method '$' sign before its name is optional(but NOT ALWAYS)}
        <...>
     \\
     <...>
     Result::<someExpression>;
  \\
  @<methodName1>(<someExpression1>,<someExpression2>,<someExpression3>,...);{method Call}

Comments:
  {someComment}
  <...>
  {otherComment}

Pointers:
  #Variable1:: :Variable2; {get the pointer to the variable2 and put it into the other variable1}
  #Variable3:: =Variable1; {get the value of the pointer stored in Variable1}{Variable contains the value stored in Variable2}
               {'='can be a prefix or an operation so this spelling "=#Variable1" is also valid}
               {be careful: if want to get the value of double pointer don't write like this "==DoubelPtr" instead write "=(=DoublePtr)" or "= =DoublePtr"}
  :Variable4:: #Variable1; {make the Variable4 act as the variable that Variable1 points on}
              {every change in the value or subvariables' values of Variable4 will affect Variable2}

Special sybols in strings and chars:
  \n - New Line
  \a - apostrophe
  \d - quotation mark
  \b - backslash

Variable and method naming:
  Variable and method names may contain only letters and digits
  for example: #123,#123abc,#abc,#abc123,#a1b2c3,#1a2b3c
  BUT if then you want to define method and its name starts with a digit you must use '$' before method's name
  for example:
    !meth 3()//<...>\\ {invalid}
    !meth $3()//<...>\\ {valid}
    !meth m3()//<...>\\ {valid}

ShortCuts:
  {if you want to add something to the variable you write}
  #i::#i+1;
  {previous example is too long, but you can write more concise}
  #i:+:1;
  {in colons you can write not only binary operations but also unary operations}
  #i:_:;{negate the value of variable}

P.S:
  you can find example programs in /ColumnTest/zProg
  yon can find descriptions of stdlib's methods in DefaultLib.txt
